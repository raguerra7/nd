##template properties
name =SAN_CPU_MEM_Report;
description = SAN CPU/Memory report (uses appcenter pm/stat APIs, ND 4.1);
tags =san-userdefined;
userDefined = true;
supportedPlatforms = All;
templateType = REPORT;
templateSubType = GENERIC;
contentType = PYTHON;
implements = ;
dependencies = ;
published = false;
imports = ;
##
##template variables
@(IsInternal=true)
string template_name;

# CPU/MEM SELECTION
@(IsMandatory=true, DisplayName="Include CPU Utilization", Description="Include CPU utilization table", Section="CPU/MEM")
boolean CPU_INCLUDED { defaultValue=true; };

@(IsMandatory=true, DisplayName="Include Memory Utilization", Description="Include Memory utilization table", Section="CPU/MEM")
boolean MEM_INCLUDED { defaultValue=true; };
##
##template content
from reportlib.preport import *
import reportlib.rest_util as rest_util
from datetime import datetime
from collections import OrderedDict
import json, traceback

from com.cisco.dcbu.vinci.rest.services.jython import WrappersResp

# --- Constantes dos endpoints (appcenter) ---
CPU_PATH = "/appcenter/cisco/ndfc/api/v1/pm/stat/cpuStatES"
MEM_PATH = "/appcenter/cisco/ndfc/api/v1/pm/stat/memoryStatES"
# parâmetros padrão (iguais aos screens: último dia)
DEFAULT_Q = ("interval=Day", "navId=-1")

def _bool(v):
    if isinstance(v, bool): return v
    return str(v).strip().lower() == "true"

def _safe_get(url_path, *params):
    """
    Tenta chamar o endpoint appcenter diretamente. Se o ambiente exigir outra forma,
    a exceção é registrada no 'Execution Status' do relatório.
    """
    return json.loads(rest_util.get(url_path, *params))

def _row_norm(row):
    e = OrderedDict()
    e["Switch Name"]   = str(row.get("entityName", ""))
    e["IP Address"]    = str(row.get("swIpAddress", ""))
    e["Low Value(%)"]  = str(row.get("minRxStr",  row.get("minStr",  "0")))
    e["Avg. Value(%)"] = str(row.get("avgRxStr",  row.get("avgStr",  "0")))
    e["High Value(%)"] = str(row.get("maxRxStr",  row.get("maxStr",  "0")))
    e["Last Updated"]  = str(row.get("lastUpdateTimeStr", ""))
    return e

def _fill_table(summary, title, rows):
    tbl = summary.add_table(title, title.replace(" ", "_").lower())
    for r in rows:
        e = _row_norm(r)
        tbl.append(e, "{}-{}".format(e["Switch Name"], e["IP Address"]))

def add_cpu_mem(report, cpu_on, mem_on):
    summary = report.add_summary()
    status  = summary.add_table("Execution Status", "status")

    added_any = False

    # CPU
    if cpu_on:
        try:
            cpu_rows = _safe_get(CPU_PATH, *DEFAULT_Q)
            status.append({"CPU API": CPU_PATH, "Count": str(len(cpu_rows))}, "cpu_api")
            _fill_table(summary, "CPU (%) - Last Day", sorted(cpu_rows, key=lambda i: i.get('lastDayMaxRx', 0), reverse=True))
            added_any = True
        except Exception as e:
            status.append({"CPU Error": str(e)}, "cpu_err")

    # Memory
    if mem_on:
        try:
            mem_rows = _safe_get(MEM_PATH, *DEFAULT_Q)
            status.append({"Mem API": MEM_PATH, "Count": str(len(mem_rows))}, "mem_api")
            _fill_table(summary, "Memory (%) - Last Day", sorted(mem_rows, key=lambda i: i.get('lastDayMaxRx', 0), reverse=True))
            added_any = True
        except Exception as e:
            status.append({"Mem Error": str(e)}, "mem_err")

    if not cpu_on and not mem_on:
        status.append({"Result": "Executed (CPU & Memory disabled in UI)"}, "res")
    elif added_any:
        status.append({"Result": "Tables added"}, "res")
    else:
        status.append({"Result": "Executed (no rows added)"}, "res")

def generateReport(context):
    resp = WrappersResp.getRespObj()
    report = Report("SAN CPU/Mem - " + (template_name if template_name else "Profile"))
    try:
        add_cpu_mem(
            report,
            _bool(CPU_INCLUDED),
            _bool(MEM_INCLUDED)
        )
        resp.setSuccessRetCode()
        resp.setValue(report)
        return resp
    except Exception as e:
        # Sempre mostra algo na aba Reports
        s = report.add_summary()
        t = s.add_table("Execution Status (Fatal)", "fatal")
        t.append({"Error": str(e), "Trace": traceback.format_exc()[:900]}, "e")
        resp.setSuccessRetCode()
        resp.setValue(report)
        return resp
##
